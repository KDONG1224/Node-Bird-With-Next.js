{"ast":null,"code":"import { all, fork, call, take, put, takeLatest, throttle, delay } from \"redux-saga/effects\";\nimport axios from \"axios\";\n\nfunction logInAPI() {\n  return axios.post(\"/api/login\", data);\n}\n\nfunction* logIn(action) {\n  try {\n    // const result = yield call(logInAPI, action.data);\n    yield delay(1000);\n    yield put({\n      type: \"LOG_IN_SUCCESS\",\n      data: result.data\n    });\n  } catch (err) {\n    yield put({\n      type: \"LOG_IN_FAILURE\",\n      data: err.resopnse.data\n    });\n  }\n}\n\nfunction logOutAPI() {\n  return axios.post(\"/api/logout\");\n}\n\nfunction* logOut() {\n  try {\n    // const result = yield call(logOutAPI);\n    yield delay(1000);\n    yield put({\n      type: \"LOG_OUT_SUCCESS\",\n      data: result.data\n    });\n  } catch (err) {\n    yield put({\n      type: \"LOG_OUT_FAILURE\",\n      data: err.resopnse.data\n    });\n  }\n}\n\nfunction addPostAPI() {\n  return axios.post(\"/api/post\", data);\n}\n\nfunction* addPost(action) {\n  try {\n    // const result = yield call(addPostAPI, action.data);\n    yield delay(1000);\n    yield put({\n      type: \"ADD_POST_SUCCESS\",\n      data: result.data\n    });\n  } catch (err) {\n    yield put({\n      type: \"ADD_POST_FAILURE\",\n      data: err.resopnse.data\n    });\n  }\n} // 이벤트 리스너(?) 만들고\n\n\nfunction* watchLogIn() {\n  // yield take(\"LOG_IN_REQUEST\", logIn);\n  yield takeLatest(\"LOG_IN_REQUEST\", logIn); // --> 치명적 단점,,, 일회용이다. 해결방법 -->  while 로 감싼다.  --> while 대신에 takeEvery를 사용한다.\n  // takeLatest --> 100번을 동시에 눌러도 마지막 1번꺼만 실행된다.\n}\n\nfunction* watchLogOut() {\n  yield takeLatest(\"LOG_OUT_REQUEST\", logOut);\n}\n\nfunction* watchAddPost() {\n  yield takeLatest(\"ADD_POST_REQUEST\", addPost);\n} // all로 등록\n\n\nexport default function* rootSaga() {\n  yield all([fork(watchLogIn), fork(watchLogOut), fork(watchAddPost)]);\n} // 제너레이터 --> function*\n// 제너레이터 실행 법 --> 함수명().next() 로 실행된다.\n// yield --> 일드 --> 중단점 --> 일드가 있는부분에서 멈춘다.\n// 제너레이터는 안에 일드를 넣어주면 그 부분에서 멈춘다.\n// saga에서는 절대 멈추지 않는 제너레이터가 있다.\n// let i = 0;\n// const gen = function* () {\n//   while (true) {\n//     yield i++;\n//   }\n// };\n// call 과 fork의 차이\n// fork 는 비동기 호출 --> 요청보내고 결과 기다리는거 상관없이 바로 다음거 실행된다.\n// call 은 동기 호출 --> 리턴할때까지 기다렸다가 호출된다.\n// saga effect\n// all, fork, call, take, put, delay, debounce, throttle, takeLatest, takeMaybe 등이 있다.","map":{"version":3,"sources":["/Users/gangdongjae/Desktop/inflearn/React-NodeBird-Next.js_with ZeroCho/code/source_code/react-nodebird-master/prepare/front/sagas/index.js"],"names":["all","fork","call","take","put","takeLatest","throttle","delay","axios","logInAPI","post","data","logIn","action","type","result","err","resopnse","logOutAPI","logOut","addPostAPI","addPost","watchLogIn","watchLogOut","watchAddPost","rootSaga"],"mappings":"AAAA,SACEA,GADF,EAEEC,IAFF,EAGEC,IAHF,EAIEC,IAJF,EAKEC,GALF,EAMEC,UANF,EAOEC,QAPF,EAQEC,KARF,QASO,oBATP;AAUA,OAAOC,KAAP,MAAkB,OAAlB;;AAEA,SAASC,QAAT,GAAoB;AAClB,SAAOD,KAAK,CAACE,IAAN,CAAW,YAAX,EAAyBC,IAAzB,CAAP;AACD;;AAED,UAAUC,KAAV,CAAgBC,MAAhB,EAAwB;AACtB,MAAI;AACF;AACA,UAAMN,KAAK,CAAC,IAAD,CAAX;AACA,UAAMH,GAAG,CAAC;AACRU,MAAAA,IAAI,EAAE,gBADE;AAERH,MAAAA,IAAI,EAAEI,MAAM,CAACJ;AAFL,KAAD,CAAT;AAID,GAPD,CAOE,OAAOK,GAAP,EAAY;AACZ,UAAMZ,GAAG,CAAC;AACRU,MAAAA,IAAI,EAAE,gBADE;AAERH,MAAAA,IAAI,EAAEK,GAAG,CAACC,QAAJ,CAAaN;AAFX,KAAD,CAAT;AAID;AACF;;AAED,SAASO,SAAT,GAAqB;AACnB,SAAOV,KAAK,CAACE,IAAN,CAAW,aAAX,CAAP;AACD;;AAED,UAAUS,MAAV,GAAmB;AACjB,MAAI;AACF;AACA,UAAMZ,KAAK,CAAC,IAAD,CAAX;AACA,UAAMH,GAAG,CAAC;AACRU,MAAAA,IAAI,EAAE,iBADE;AAERH,MAAAA,IAAI,EAAEI,MAAM,CAACJ;AAFL,KAAD,CAAT;AAID,GAPD,CAOE,OAAOK,GAAP,EAAY;AACZ,UAAMZ,GAAG,CAAC;AACRU,MAAAA,IAAI,EAAE,iBADE;AAERH,MAAAA,IAAI,EAAEK,GAAG,CAACC,QAAJ,CAAaN;AAFX,KAAD,CAAT;AAID;AACF;;AAED,SAASS,UAAT,GAAsB;AACpB,SAAOZ,KAAK,CAACE,IAAN,CAAW,WAAX,EAAwBC,IAAxB,CAAP;AACD;;AAED,UAAUU,OAAV,CAAkBR,MAAlB,EAA0B;AACxB,MAAI;AACF;AACA,UAAMN,KAAK,CAAC,IAAD,CAAX;AACA,UAAMH,GAAG,CAAC;AACRU,MAAAA,IAAI,EAAE,kBADE;AAERH,MAAAA,IAAI,EAAEI,MAAM,CAACJ;AAFL,KAAD,CAAT;AAID,GAPD,CAOE,OAAOK,GAAP,EAAY;AACZ,UAAMZ,GAAG,CAAC;AACRU,MAAAA,IAAI,EAAE,kBADE;AAERH,MAAAA,IAAI,EAAEK,GAAG,CAACC,QAAJ,CAAaN;AAFX,KAAD,CAAT;AAID;AACF,C,CAED;;;AACA,UAAUW,UAAV,GAAuB;AACrB;AACA,QAAMjB,UAAU,CAAC,gBAAD,EAAmBO,KAAnB,CAAhB,CAFqB,CAGrB;AACA;AACD;;AAED,UAAUW,WAAV,GAAwB;AACtB,QAAMlB,UAAU,CAAC,iBAAD,EAAoBc,MAApB,CAAhB;AACD;;AAED,UAAUK,YAAV,GAAyB;AACvB,QAAMnB,UAAU,CAAC,kBAAD,EAAqBgB,OAArB,CAAhB;AACD,C,CAED;;;AACA,eAAe,UAAUI,QAAV,GAAqB;AAClC,QAAMzB,GAAG,CAAC,CAACC,IAAI,CAACqB,UAAD,CAAL,EAAmBrB,IAAI,CAACsB,WAAD,CAAvB,EAAsCtB,IAAI,CAACuB,YAAD,CAA1C,CAAD,CAAT;AACD,C,CAED;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA","sourcesContent":["import {\n  all,\n  fork,\n  call,\n  take,\n  put,\n  takeLatest,\n  throttle,\n  delay,\n} from \"redux-saga/effects\";\nimport axios from \"axios\";\n\nfunction logInAPI() {\n  return axios.post(\"/api/login\", data);\n}\n\nfunction* logIn(action) {\n  try {\n    // const result = yield call(logInAPI, action.data);\n    yield delay(1000);\n    yield put({\n      type: \"LOG_IN_SUCCESS\",\n      data: result.data,\n    });\n  } catch (err) {\n    yield put({\n      type: \"LOG_IN_FAILURE\",\n      data: err.resopnse.data,\n    });\n  }\n}\n\nfunction logOutAPI() {\n  return axios.post(\"/api/logout\");\n}\n\nfunction* logOut() {\n  try {\n    // const result = yield call(logOutAPI);\n    yield delay(1000);\n    yield put({\n      type: \"LOG_OUT_SUCCESS\",\n      data: result.data,\n    });\n  } catch (err) {\n    yield put({\n      type: \"LOG_OUT_FAILURE\",\n      data: err.resopnse.data,\n    });\n  }\n}\n\nfunction addPostAPI() {\n  return axios.post(\"/api/post\", data);\n}\n\nfunction* addPost(action) {\n  try {\n    // const result = yield call(addPostAPI, action.data);\n    yield delay(1000);\n    yield put({\n      type: \"ADD_POST_SUCCESS\",\n      data: result.data,\n    });\n  } catch (err) {\n    yield put({\n      type: \"ADD_POST_FAILURE\",\n      data: err.resopnse.data,\n    });\n  }\n}\n\n// 이벤트 리스너(?) 만들고\nfunction* watchLogIn() {\n  // yield take(\"LOG_IN_REQUEST\", logIn);\n  yield takeLatest(\"LOG_IN_REQUEST\", logIn);\n  // --> 치명적 단점,,, 일회용이다. 해결방법 -->  while 로 감싼다.  --> while 대신에 takeEvery를 사용한다.\n  // takeLatest --> 100번을 동시에 눌러도 마지막 1번꺼만 실행된다.\n}\n\nfunction* watchLogOut() {\n  yield takeLatest(\"LOG_OUT_REQUEST\", logOut);\n}\n\nfunction* watchAddPost() {\n  yield takeLatest(\"ADD_POST_REQUEST\", addPost);\n}\n\n// all로 등록\nexport default function* rootSaga() {\n  yield all([fork(watchLogIn), fork(watchLogOut), fork(watchAddPost)]);\n}\n\n// 제너레이터 --> function*\n// 제너레이터 실행 법 --> 함수명().next() 로 실행된다.\n// yield --> 일드 --> 중단점 --> 일드가 있는부분에서 멈춘다.\n// 제너레이터는 안에 일드를 넣어주면 그 부분에서 멈춘다.\n\n// saga에서는 절대 멈추지 않는 제너레이터가 있다.\n// let i = 0;\n// const gen = function* () {\n//   while (true) {\n//     yield i++;\n//   }\n// };\n\n// call 과 fork의 차이\n// fork 는 비동기 호출 --> 요청보내고 결과 기다리는거 상관없이 바로 다음거 실행된다.\n// call 은 동기 호출 --> 리턴할때까지 기다렸다가 호출된다.\n\n// saga effect\n// all, fork, call, take, put, delay, debounce, throttle, takeLatest, takeMaybe 등이 있다.\n"]},"metadata":{},"sourceType":"module"}