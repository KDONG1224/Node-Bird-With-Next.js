{"ast":null,"code":"import { createWrapper } from 'next-redux-wrapper';\nimport { createStore, applyMiddleware, compose } from 'redux';\nimport reducer from '../reducers';\nimport { composeWithDevTools } from 'redux-devtools-extension';\n\nconst configureStore = () => {\n  const middlewares = [];\n  const enhancer = false ? compose(applyMiddleware(...middlewares)) : composeWithDevTools(applyMiddleware(...middlewares));\n  const store = createStore(reducer, enhancer);\n  store.dispatch({\n    type: 'CHANGE_NICKNAME',\n    data: 'KDONG'\n  });\n  return store;\n};\n\nconst wrapper = createWrapper(configureStore, {\n  debug: true\n});\nexport default wrapper; // redux, mobx 등을 사용하는 이유?\n// 여러 컴포넌트에서 공통적으로 사용하는 데이터들을 부모로 만들어서 수동으로 props로 보내주는 과정을 매우 귀찮기 때문에\n// 중앙에서 하나로 관리하여 뿌려주는 역할을 한다.\n// 중앙저장소 역할... 하나로 모아두고 필요로 하는 컴포넌트에서 전체 or 부분을 가져가서 사용할 수 있게 한다.\n// 대표적인게 context API, redux, mobX등이 있다.\n// 규모가 어느정도 되는 서비스이면 중앙저장소를 하나정도는 둬야 한다.  --> redux > 초보탈충 생산성 향상: mob-X > 가볍게 context API\n// redux 는 원리가 간단하기 때문에 에러가 나면 추적하기 쉽다. 단점으로는 코드량이 많아진다. 대신 앱을 안정적이다.\n// 몹엑스는 코드량은 적어지지만 실수를 하면 추적하기가 어렵다. (트레이드 오프(?))\n// contextAPI 와 redux, mob-X 의 차이점으로는 '비동기'를 지원하기 쉽냐? 어렵냐? 의 차이\n// 서버에서 데이터를 받아오는 건 항상 '비동기'이다. --> 비동기를 다룰때 항상 실패를 생각해야한다.\n// 데이터를 요청, 성공, 실패 --> 3가지의 단계로 구분이 된다.\n// context API는 직접 위의 3단계를 직접 구현해야 한다.\n// 단점으로는 useEffect, axios.get, .then, .catch 등의 코드가 컴포넌트에 많이 들어간다.\n// 컴포넌트는 화면 그리는 거에만 집중하는게 좋은데 데이터를 가져오는 것은 좋지 않고, 의도치 않은 데이터 중복요청이 생길 수 있다.\n// 컴포넌트는 데이터를 받아서 화면만 그려준다. 라고 생각하는게 좋다.\n// 데이터 요청은 별도의 모듈이나, 라이브러리가 하는게 좋다.  --> redux, mob X 등\n// context API 는 직접 구성해야 하고, 데이터 요청을 컴포넌트 밖으로 뺄 수 있지만, 그렇게 하면 redux, mob X와 비슷하게 된다.\n// 즉, 비동기 요청이 많으면 redux, mobX를 사용하는게 좋다.\n// 앱이 커지면 중앙저장소가 커지기 때문에 중앙저장소도 적절히 쪼개주는게 좋은데 redux는 그 시스템을 reducer 를 활용하여 쪼개는\n// 시스템을 잘 가쳐져 있다.\n// redux 개념\n// reduce에서 이름을 따왔다.\n// 데이터 중앙 저장소에 저장도니 데이터를 각 컴포넌트에서 필요할 때 꺼내서 사용할 수 있다.\n// 데이터를 가져가서 수정, 추가, 삭제를 하기도 할 수 있다. 이때 데이터를 변경하기 위해 action 을 만들어 줘야한다.\n// aciton에서 type은 action의 이름, data는 변경할 데이터 --> 이 액션을 dispatch하면 중앙 저장소가 변경된다.\n// 그럼 reducer는 무엇이냐?\n// 액션을 디스패치한다고 해서 알아서 데이터가 변경되는 것이 아니다.\n// 직접 어떻게 변경되야 하는지 reducer에 정의해줘야 한다.\n// 이때 switch 문을 통해서 정의해준다.\n// 변경하고 싶을 때 액션을 만들어 주고, 어떻게 처리할 껀지도 만들어주고, --> 코드량이 많아진다.\n// 굳이? 귀찮게 왜 사용하냐?\n// 실제로 해보면 상당히 좋다. 왜? 액션 하나하나가 redux에 내역들이 작성되어 추적하기가 쉽다.\n// 액션을 굳이 만들어주는 이유는 기록이 남기때문에,,, case문 안에서 return을 적어주는 이유는 '불변성' 때문이다.\n// {} === {} --> false / const a ={}; const b = a; a === b --> true 참조 관계면 true이다.\n// 객체를 새로만들면 false 가 나온다. 객체에서 바뀌는 부분만 작성해서 새로만들어서 보내준다.\n// 객체를 새로 만들어야 추척이 된다.\n// ex) 로 해야 추적이 쉽다.\n// const prev = { name: 'kdong' }\n// const next = { name: '동재' }\n// 직접 바꾸면 히스토리, 내역이 없어지기 때문에 추적이 어렵다. --> 히스토리 관리를 하기 위해 사용한다.\n// 전체를 다 적지 않고 ...state 를 하는 이유는 메모리를 아끼기 위해서 한다. --> 참조관계가 된다.\n// 액션을 할때마다 새로운 객체를 생성하니까 메모리를 많이 잡아 먹는다.\n// 새로만든 객체는 메모리 정리가 될때 사라진다. --> 배포모드가 되면 히스토리를 계속 정리를 한다. --> 배포모드일때 메모리 정리한다.","map":{"version":3,"sources":["/Users/gangdongjae/Desktop/inflearn/[리뉴얼] React로 NodeBird SNS 만들기/code/source_code/react-nodebird-master/prepare/front/store/configureStore.js"],"names":["createWrapper","createStore","applyMiddleware","compose","reducer","composeWithDevTools","configureStore","middlewares","enhancer","store","dispatch","type","data","wrapper","debug"],"mappings":"AAAA,SAASA,aAAT,QAA8B,oBAA9B;AACA,SAASC,WAAT,EAAsBC,eAAtB,EAAuCC,OAAvC,QAAsD,OAAtD;AACA,OAAOC,OAAP,MAAoB,aAApB;AACA,SAASC,mBAAT,QAAoC,0BAApC;;AAEA,MAAMC,cAAc,GAAG,MAAM;AAC3B,QAAMC,WAAW,GAAG,EAApB;AACA,QAAMC,QAAQ,GACZ,QACIL,OAAO,CAACD,eAAe,CAAC,GAAGK,WAAJ,CAAhB,CADX,GAEIF,mBAAmB,CAACH,eAAe,CAAC,GAAGK,WAAJ,CAAhB,CAHzB;AAIA,QAAME,KAAK,GAAGR,WAAW,CAACG,OAAD,EAAUI,QAAV,CAAzB;AACAC,EAAAA,KAAK,CAACC,QAAN,CAAe;AACbC,IAAAA,IAAI,EAAE,iBADO;AAEbC,IAAAA,IAAI,EAAE;AAFO,GAAf;AAIA,SAAOH,KAAP;AACD,CAZD;;AAcA,MAAMI,OAAO,GAAGb,aAAa,CAACM,cAAD,EAAiB;AAC5CQ,EAAAA,KAAK;AADuC,CAAjB,CAA7B;AAIA,eAAeD,OAAf,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["import { createWrapper } from 'next-redux-wrapper';\nimport { createStore, applyMiddleware, compose } from 'redux';\nimport reducer from '../reducers';\nimport { composeWithDevTools } from 'redux-devtools-extension';\n\nconst configureStore = () => {\n  const middlewares = [];\n  const enhancer =\n    process.env.NODE_ENV === 'production'\n      ? compose(applyMiddleware(...middlewares))\n      : composeWithDevTools(applyMiddleware(...middlewares));\n  const store = createStore(reducer, enhancer);\n  store.dispatch({\n    type: 'CHANGE_NICKNAME',\n    data: 'KDONG',\n  });\n  return store;\n};\n\nconst wrapper = createWrapper(configureStore, {\n  debug: process.env.NODE_ENV === 'development',\n});\n\nexport default wrapper;\n\n// redux, mobx 등을 사용하는 이유?\n// 여러 컴포넌트에서 공통적으로 사용하는 데이터들을 부모로 만들어서 수동으로 props로 보내주는 과정을 매우 귀찮기 때문에\n// 중앙에서 하나로 관리하여 뿌려주는 역할을 한다.\n// 중앙저장소 역할... 하나로 모아두고 필요로 하는 컴포넌트에서 전체 or 부분을 가져가서 사용할 수 있게 한다.\n// 대표적인게 context API, redux, mobX등이 있다.\n// 규모가 어느정도 되는 서비스이면 중앙저장소를 하나정도는 둬야 한다.  --> redux > 초보탈충 생산성 향상: mob-X > 가볍게 context API\n// redux 는 원리가 간단하기 때문에 에러가 나면 추적하기 쉽다. 단점으로는 코드량이 많아진다. 대신 앱을 안정적이다.\n// 몹엑스는 코드량은 적어지지만 실수를 하면 추적하기가 어렵다. (트레이드 오프(?))\n// contextAPI 와 redux, mob-X 의 차이점으로는 '비동기'를 지원하기 쉽냐? 어렵냐? 의 차이\n// 서버에서 데이터를 받아오는 건 항상 '비동기'이다. --> 비동기를 다룰때 항상 실패를 생각해야한다.\n// 데이터를 요청, 성공, 실패 --> 3가지의 단계로 구분이 된다.\n// context API는 직접 위의 3단계를 직접 구현해야 한다.\n// 단점으로는 useEffect, axios.get, .then, .catch 등의 코드가 컴포넌트에 많이 들어간다.\n// 컴포넌트는 화면 그리는 거에만 집중하는게 좋은데 데이터를 가져오는 것은 좋지 않고, 의도치 않은 데이터 중복요청이 생길 수 있다.\n// 컴포넌트는 데이터를 받아서 화면만 그려준다. 라고 생각하는게 좋다.\n// 데이터 요청은 별도의 모듈이나, 라이브러리가 하는게 좋다.  --> redux, mob X 등\n// context API 는 직접 구성해야 하고, 데이터 요청을 컴포넌트 밖으로 뺄 수 있지만, 그렇게 하면 redux, mob X와 비슷하게 된다.\n// 즉, 비동기 요청이 많으면 redux, mobX를 사용하는게 좋다.\n// 앱이 커지면 중앙저장소가 커지기 때문에 중앙저장소도 적절히 쪼개주는게 좋은데 redux는 그 시스템을 reducer 를 활용하여 쪼개는\n// 시스템을 잘 가쳐져 있다.\n\n// redux 개념\n// reduce에서 이름을 따왔다.\n// 데이터 중앙 저장소에 저장도니 데이터를 각 컴포넌트에서 필요할 때 꺼내서 사용할 수 있다.\n// 데이터를 가져가서 수정, 추가, 삭제를 하기도 할 수 있다. 이때 데이터를 변경하기 위해 action 을 만들어 줘야한다.\n// aciton에서 type은 action의 이름, data는 변경할 데이터 --> 이 액션을 dispatch하면 중앙 저장소가 변경된다.\n// 그럼 reducer는 무엇이냐?\n// 액션을 디스패치한다고 해서 알아서 데이터가 변경되는 것이 아니다.\n// 직접 어떻게 변경되야 하는지 reducer에 정의해줘야 한다.\n// 이때 switch 문을 통해서 정의해준다.\n// 변경하고 싶을 때 액션을 만들어 주고, 어떻게 처리할 껀지도 만들어주고, --> 코드량이 많아진다.\n// 굳이? 귀찮게 왜 사용하냐?\n// 실제로 해보면 상당히 좋다. 왜? 액션 하나하나가 redux에 내역들이 작성되어 추적하기가 쉽다.\n// 액션을 굳이 만들어주는 이유는 기록이 남기때문에,,, case문 안에서 return을 적어주는 이유는 '불변성' 때문이다.\n// {} === {} --> false / const a ={}; const b = a; a === b --> true 참조 관계면 true이다.\n// 객체를 새로만들면 false 가 나온다. 객체에서 바뀌는 부분만 작성해서 새로만들어서 보내준다.\n// 객체를 새로 만들어야 추척이 된다.\n// ex) 로 해야 추적이 쉽다.\n// const prev = { name: 'kdong' }\n// const next = { name: '동재' }\n// 직접 바꾸면 히스토리, 내역이 없어지기 때문에 추적이 어렵다. --> 히스토리 관리를 하기 위해 사용한다.\n// 전체를 다 적지 않고 ...state 를 하는 이유는 메모리를 아끼기 위해서 한다. --> 참조관계가 된다.\n// 액션을 할때마다 새로운 객체를 생성하니까 메모리를 많이 잡아 먹는다.\n// 새로만든 객체는 메모리 정리가 될때 사라진다. --> 배포모드가 되면 히스토리를 계속 정리를 한다. --> 배포모드일때 메모리 정리한다.\n"]},"metadata":{},"sourceType":"module"}